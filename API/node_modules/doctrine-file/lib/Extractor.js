'use strict';

exports.__esModule = true;

var _doctrine = require('doctrine');

var _stream = require('stream');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jsdoc = {
    singleLine: /^\s*(\/\*{2}.*\*\/)\s*$/,
    start: /^\s*\/\*{2}\s*$/,
    line: /^\s*\*.*$/,
    end: /^\s*\*\/\s*$/
};

var Extractor = function (_Transform) {
    _inherits(Extractor, _Transform);

    function Extractor() {
        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Extractor);

        var _this = _possibleConstructorReturn(this, _Transform.call(this, { objectMode: true }));

        _this.unfinishedChunk = [];
        _this.opts = {};

        _this.opts = opts;
        return _this;
    }

    Extractor.prototype.resetChunk = function resetChunk() {
        this.unfinishedChunk = [];
    };

    Extractor.prototype.addLine = function addLine(line) {
        var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (reset) this.resetChunk();
        this.unfinishedChunk.push(line);
    };

    Extractor.prototype.getRawCommentAndReset = function getRawCommentAndReset() {
        var comment = this.unfinishedChunk.join('\n');
        this.resetChunk();

        return comment;
    };

    Extractor.prototype.consumeLine = function consumeLine(line) {
        var match = line.match(jsdoc.singleLine);
        if (match) {
            // singleline
            return this.addDoc(match[1].trim());
        } else if (line.match(jsdoc.start)) {
            // start multiline
            this.addLine(line, true);
        } else if (this.unfinishedChunk.length) {
            if (line.match(jsdoc.end)) {
                // end multiline
                this.addLine(line);

                return this.addDoc(this.getRawCommentAndReset());
            } else if (line.match(jsdoc.line)) {
                // line multiline
                this.addLine(line);
            } else {
                // invalid line inbetween jsdoc
                this.resetChunk();
            }
        }

        return null;
    };

    Extractor.prototype.addDoc = function addDoc(docBlock) {
        var comment = (0, _doctrine.parse)(docBlock, Object.assign({}, this.opts, { unwrap: true }));
        // $FlowIssue This is correct as objectMode === true
        this.push(comment);

        return comment;
    };

    Extractor.prototype._transform = function _transform(chunk, encoding, callback) {
        var lines = chunk.toString().split(/\r?\n/);

        while (lines.length) {
            this.consumeLine(lines.shift());
        }

        callback();
    };

    Extractor.prototype.extract = function extract(content) {
        var comments = [];
        var lines = content.toString().split(/\r?\n/);

        while (lines.length) {
            var comment = this.consumeLine(lines.shift());
            if (comment) comments.push(comment);
        }

        return comments;
    };

    return Extractor;
}(_stream.Transform);

exports.default = Extractor;